---
layout  : wiki
title   : Combine을 통해 Firestore에서 데이터를 불러오자! 
summary : Combine + Firestore
date    : 2023-01-08 02:53:12 +0900
updated : 2023-01-08 02:54:21 +0900
tags    : combine
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

# Combine을 통해 Firestore에서 데이터를 불러오자!

-   다양한 입력에 반응하는 무언가를 설정하는 경우

- Combine으로 Firestore 연동하여 데이터 가져오기

- View
- ViewModel
- Service

- View
- ViewModel
- Service
- Repository
- Provider

# 서론

[공식 문서](https://developer.apple.com/documentation/combine) 에서 `Combine`에 대해 다음과 같이 정의합니다.

> Customize handling of asynchronous events by combining event-processing operators.

> 이벤트-프로세스하는 오퍼레이터들을 결합하여 비동기 이벤트들을 다루는 것을 개인화하는 것

`Operator`에 대한 개념이 명확하지 않아, 이해가 빠르게 되진 않지만 `어떤 것들을 결합`하여 비동기 이벤트들을 제 입맛에 맞게 다룰 수 있게 해주는 기술이라고 생각이 드네요.
조금 더 깊게 들어가 볼까요?

> The Combine framework provides a declarative Swift API for processing values over time. These values can represent many kinds of asynchronous events. Combine declares _publishers_ to expose values that can change over time, and _subscribers_ to receive those values from the publishers.

> 이 Combine Framework는 시간의 흐름에 따르는 values을 처리하는 선언형 스위프트 API를 제공한다.
> 이 values는 다양한 종류의 비동기 이벤트들을 의미할 수 있다. Combine은 _publishers_ 를 선언하여 시간의 흐름에 따라 변할 수 있는 values를 노출하고, _subscribers_ 를 선언하여 publishers로 부터 values를 받을 수 있게 한다.

이 문장 안에 `Combine`을 이해하기 위한 모든 개념들이 들어와 있네요!
나타난 필수 용어를 정리해 볼까요?

필수 용어
- Publisher
- Subscriber
- Operator

- 언제 Combine을 쓰면 좋은지
- 나는 어떻게 Combine을 이용하려 했는지


# 본론

- 각 파일의 역할 분리
	- 그 이유
- 동작 방식 그리기?

- 그 예시

- ViewModel
```swift
import Combine
import SwiftUI


class BadgesViewModel: ObservableObject { 
    @Published var badges: [Badge] = [Badge]()
    private var cancellables = Set<AnyCancellable>()
    
    
    func loadBadges() {
        BadgesService.fetchBadges()
            .sink { (completion) in
                switch completion {
                case .failure(let error):
                    print(error)
                    return
                case .finished:
                    return
                    
                }
            } receiveValue: { [weak self] (badges) in
                self?.badges = badges
            }
            .store(in: &cancellables)
    }
}

```

- Service
```swift
//
//  BadgesService.swift
//  Tinowledge
//
//  Created by tae on 2023/01/05.
//

import Combine
import FirebaseFirestore
import FirebaseFirestoreSwift

struct BadgesService {
    static let db = Firestore.firestore()
    
    static func fetchBadges() -> AnyPublisher<[Badge], Error> {
        Future<[Badge], Error> { promise in
            self.db.collection("Badges")
                .getDocuments { (snapshot, error) in
                    if let error = error {
                        promise(.failure(error))
                        return
                    }
                    guard let snapshot = snapshot else {
                        print("snapshot error")
                        return
                    }
                    
                    var items = [Badge]()
                    snapshot.documents.forEach { document in
                        if let item = try? document.data(as: Badge.self) {
                            print("badge : \(item)")
                            items.append(item)
                        }
                        
                    }
                    promise(.success(items))
                    
                }
        }
        .eraseToAnyPublisher()
    }
}

```


# 결론

- 많이 배웠다!
- 앱의 규모가 커질 수록, 기능이 많아질 수록 비대해지는 것
- Publisher의 operators를 적절히 사용할 수 있는 것이 중요하겠다!
